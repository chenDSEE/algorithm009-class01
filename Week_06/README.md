- 动态规划(Dynamic Programming)
  - 特点
    - 差异性：最优子结构、中途可以 淘汰 次优解
      - 通过子问题的最优值推出规模更大的问题的最优值（此乃最优子结构）
        而最优子结构是相对的，在这个问题中，采用这样的策略来计算的话，分割出来的每一个子问题符合最优子结构
      - 所以，当此时不符合最优子结构的话，很简单，更换你的策略就好，让你的策略能够将大问题分割为一个个子问题，而且通过每一个子问题的值（不一定是取最优值，可能还是相加、相减）推导出大问题的最优终极答案
    - 共性：找到重复子问题
    - 它的本质就是递归，跟 递归\分治 并没有本质上的区别（关键是看有没有最优的子结构）
  - 三步走解题（三个核心点）
    1. 最优子结构：opt[n] = best_of(
    2. opt[n - 1], opt[n - 2], ...);
    3. 储存中间状态：opt[i]
       1. 存储当前由 DP 方程计算出来的新状态，当前状态日后能够被 DP 方程纳入考虑之中
       2. 之所以要存储起来，就是为了消除重叠的子问题。
       3. 当遇上一个之前解决过的子问题，那我直接从储存中找出来就完事了。
       4. 更进一步则是，通过状态转移方程，新状态就是从旧状态推演出来的，那样就从根本上杜绝了遇上重复子问题的可能
        5. 递推公式（状态转换方程，DP 方程）
           	Fib：opt[i] = opt[n - 1] + opt[n - 2]
           	二维路径：
            1. opt[i][j] = opt[i + 1][j] + opt[i][j + 1](从这里到终点有几种方法？)
            2. opt[i][j] = opt[i - 1][j] + opt[i][j - 1](从起点到这里有几种方法？)

- 辅助根据旧状态来推演得出新状态
- 他是能够回溯的，因为这是会保存中间状态的，当中间遇上了个什么障碍物的时候，他也是要作出一些反应的。
- 这时候这个反应，将会被继承下去。因为 DP 的方式中，新的状态结果，将会由旧的状态得出，所以，DP 只需要你老老实实的更新当前状态就好，而旧状态对新状态的影响，是 DP 方程来进行决策的