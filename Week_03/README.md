# 递归通用模板

```c++
void recusion_fun(int level, int param)
{
    // terminator
    // 本次、该方向的探索到达了尽头，开始逐层向上返回（可开始 逐层传递 返回值）
    if (level > MAX_LEVEL) {
        // process result
        return answer.push_back(xxx);
    }
    
    
    // process current level logic
    // 在这里可以根据题目提前做些判断处理，提前终止不满足要求的 case（剪枝）
    new_param = process(level, param);
    
    
    
    // drill down
    // 可能会向多个不同的方向进行尝试（所以此时会有多个 fun 调用，但传入的参数会有所不同）
    recusion_fun(level + 1, new_param);
    
    
    // (merge, use in divie-and-conquer)
    
    
    // restore current level status, to return back last level
    /* 1.不一定会有，主要用来恢复在 drill down 的时候改变过的成员变量、全局、static 变量，以
     *   确保返回后环境一致；
     * 2.为了让返回后的现场不被破坏，那自然是这一层作出的改变，就由这一层来进行恢复。
     *   这样的话，递归返回之后的上一层就不用顾虑下面可能会带来的影响。
     */   
}
```

![1591529186134](C:\Users\69524\AppData\Roaming\Typora\typora-user-images\1591529186134.png)



## 递归的关键思想点

### 关键点（最近、重复、子问题）

- 最近
  - 要进行颗粒度最为细小的递归
- 重复
  - 这样你的代码才能够有效的复用
  - 这就是所谓的可优化部分，可以进行优化的点
    - 代码行数
    - 代码执行时间
    - 代码占用内存空间
- 子问题
  - 注意拆分的时候要机型合理的拆分
  - 拆分的颗粒度一定要最小
  - 拆分的要求是，每一层的逻辑都是一致的，但是层控因子会逐渐变化
  - 子问题，关注的是自己这一层的问题，并不关心上下一层怎样，只关心这一层要怎样，遥望上一层返回什么值、要往下进行怎样的新探索
  - 想清楚，每一个子问题可能面临的各种情况（拆分、各个应对的重点 divide-and-conquer，逐个击破）

- NOTE：
  - 这一层并不会对下一层造成影响，思考问题的时候不要串，关注的重点不是上一层会怎样、下一层会怎样。而是==面对上一层传递进来的参数，我这一层应该怎么面对，可能会出现哪几种不同的情况，我怎么将这几种情况区分开来，并进行相对应的处理==
  - 每一层的处理流程都是一样的，区别就是传递参数不同，可能走进的 if 分支不一样罢了
    - 所以子问题的正确拆解，应该是能够应对所有可能的分支，才是正确的
  - 不要人肉递归，不要脑补状态树进行，人肉递归的思考！不断联系不同的递归层只会增加你思考的难度！每一层递归要走的逻辑都是一样的，你可以先写核心的关键==递进==处理，然后再将边缘 case 进行分支限制处理。==（不会写就先上模板，再写核心递进，根据递进逐步完善要传递什么参数，然后是递归的尽头，最后将边缘case，可能发生的分支逐步完善）==
  - 递归 = 递（子问题的拆解，怎么深入下一层） + 归（回溯，怎么退回以前）
    - 递 向 归 的转换 = 终止条件
  - 
  - 当然，上面说的一切，前提是==这一题能够用递归来做==